<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper.io Solo üü©</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        canvas {
            border: 5px solid #2a9d8f;
            background-color: #eee;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            touch-action: none; /* Emp√™che le zoom/d√©filement sur mobile */
        }

        #score-panel {
            margin-top: 15px;
            font-size: 1.2em;
            color: #333;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            width: 300px;
            text-align: center;
        }

        #controls {
            margin-top: 15px;
            text-align: center;
            color: #555;
        }

        /* Styles pour les boutons de contr√¥le sur mobile */
        #mobile-controls {
            display: none; /* Cach√© par d√©faut, affich√© en JS si mobile */
            margin-top: 20px;
            width: 300px;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
        }
        
        .control-row {
            display: flex;
            justify-content: center;
        }

        .control-button {
            padding: 15px 25px;
            margin: 5px;
            background-color: #e76f51;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            user-select: none;
            flex: 1;
        }
        
        .control-button:active {
            background-color: #f4a261;
        }
        
        #up-btn, #down-btn {
            width: 100px; /* Aligner les boutons haut/bas */
        }
    </style>
</head>
<body>

    <h1>Paper.io Solo üéÆ</h1>

    <canvas id="game-canvas" width="600" height="400"></canvas>

    <div id="score-panel">
        Territoire captur√© : <span id="area-score">0</span>%
    </div>
    
    <div id="controls">
        Utilisez les **touches fl√©ch√©es** pour vous d√©placer.
    </div>

    <div id="mobile-controls">
        <div class="control-row">
            <button id="up-btn" class="control-button">‚ñ≤</button>
        </div>
        <div class="control-row">
            <button id="left-btn" class="control-button">‚óÄ</button>
            <button id="right-btn" class="control-button">‚ñ∂</button>
        </div>
        <div class="control-row">
            <button id="down-btn" class="control-button">‚ñº</button>
        </div>
    </div>
    
    <script>
        // --- CONFIGURATION DU JEU ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const TILE_SIZE = 10;
        const PLAYER_COLOR = '#e76f51';
        const TRAIL_COLOR = '#f4a261';
        const BASE_COLOR = '#2a9d8f';
        const ENEMY_COLOR = '#264653';

        // --- √âTAT DU JEU ---
        let player = { x: 5, y: 5, dx: 0, dy: 0, speed: TILE_SIZE };
        let territory = []; // Repr√©sente le territoire du joueur (coordonn√©es)
        let trail = [];     // Repr√©sente la ligne trac√©e hors du territoire
        let isMoving = false;
        let isDead = false;
        let territoryArea = 0; // Zone captur√©e

        // Initialisation de la grille (le monde)
        const gridCols = WIDTH / TILE_SIZE;
        const gridRows = HEIGHT / TILE_SIZE;

        // Remplir le territoire initial (coin sup√©rieur gauche)
        function initializeTerritory() {
            territory = [];
            territoryArea = 0;
            // Remplir 5x5 dans le coin pour le territoire de d√©part
            for (let x = 0; x < 5; x++) {
                for (let y = 0; y < 5; y++) {
                    territory.push({ x: x, y: y });
                }
            }
        }

        // --- GESTION DES COMMANDES (Clavier et Mobile) ---
        function setDirection(dx, dy) {
            // Emp√™che le joueur de se retourner imm√©diatement (r√®gle Paper.io)
            if (player.dx !== -dx || player.dy !== -dy) {
                player.dx = dx;
                player.dy = dy;
                isMoving = true;
            }
        }

        // √âv√©nements clavier
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                    setDirection(0, -1);
                    break;
                case 'ArrowDown':
                    setDirection(0, 1);
                    break;
                case 'ArrowLeft':
                    setDirection(-1, 0);
                    break;
                case 'ArrowRight':
                    setDirection(1, 0);
                    break;
            }
            e.preventDefault(); // Emp√™che le d√©filement de la page
        });
        
        // √âv√©nements mobiles
        document.getElementById('mobile-controls').style.display = 'block'; // Afficher les contr√¥les
        document.getElementById('up-btn').addEventListener('click', () => setDirection(0, -1));
        document.getElementById('down-btn').addEventListener('click', () => setDirection(0, 1));
        document.getElementById('left-btn').addEventListener('click', () => setDirection(-1, 0));
        document.getElementById('right-btn').addEventListener('click', () => setDirection(1, 0));


        // --- LOGIQUE DE JEU ---

        /** * V√©rifie si des coordonn√©es font partie du territoire.
         * @returns {boolean}
         */
        function isTerritory(x, y) {
            return territory.some(t => t.x === x && t.y === y);
        }

        /**
         * D√©place le joueur et g√®re la capture/collision.
         */
        function movePlayer() {
            if (!isMoving || isDead) return;

            // Nouvelle position
            let newX = player.x + player.dx;
            let newY = player.y + player.dy;

            // 1. Gestion des collisions avec les murs
            if (newX < 0 || newX >= gridCols || newY < 0 || newY >= gridRows) {
                isDead = true;
                alert('Partie termin√©e ! Collision avec le mur.');
                return;
            }

            // 2. Collision avec sa propre ligne (mort)
            if (!isTerritory(player.x, player.y) && trail.some(t => t.x === newX && t.y === newY)) {
                isDead = true;
                alert('Partie termin√©e ! Vous avez coup√© votre propre ligne.');
                return;
            }

            player.x = newX;
            player.y = newY;

            // 3. Gestion du trac√© de ligne (hors territoire)
            if (!isTerritory(player.x, player.y)) {
                // Ajouter le point au trac√© si ce n'est pas d√©j√† le dernier
                const lastTrail = trail[trail.length - 1];
                if (!lastTrail || lastTrail.x !== player.x || lastTrail.y !== player.y) {
                    trail.push({ x: player.x, y: player.y });
                }
            } 
            // 4. Gestion de la capture (Retour au territoire)
            else if (isTerritory(player.x, player.y) && trail.length > 0) {
                captureTerritory();
                trail = []; // Vider la ligne
            }
        }
        
        /**
         * Impl√©mentation du remplissage de zone (Flood Fill/BFS simplifi√©).
         */
        function captureTerritory() {
            // Trouver la zone vide √† l'int√©rieur du trac√©
            // NOTE : C'est la partie la plus complexe d'un jeu .io.
            // Nous utilisons ici une simplification : chercher le premier point
            // non-territoire adjacent au trac√© et l'utiliser comme point de d√©part
            // pour le remplissage (l'algo 'Flood Fill').
            
            const filledTiles = [];
            
            // On consid√®re que toutes les cases non-territoire, mais qui ne font pas partie 
            // du trac√© sont celles √† capturer. Pour simplifier, on ne g√®re pas les "trous" ici.
            
            // Algorithme de remplissage (tr√®s simplifi√©) :
            // Trouver le point de d√©part ext√©rieur au territoire.
            
            // Pour le solo, on va simplement utiliser le trac√© pour cr√©er un polygone
            // et remplir les points qui sont 'dedans' mais pas encore dans le territoire.

            let minX = Math.min(...trail.map(t => t.x), player.x);
            let maxX = Math.max(...trail.map(t => t.x), player.x);
            let minY = Math.min(...trail.map(t => t.y), player.y);
            let maxY = Math.max(...trail.map(t => t.y), player.y);
            
            // Parcourir le rectangle englobant le trac√©
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    // Si la case n'est pas encore captur√©e ET qu'elle n'est pas le point courant du trac√©
                    if (!isTerritory(x, y)) {
                        filledTiles.push({ x: x, y: y });
                    }
                }
            }
            
            // Filtrer les tuiles qui √©taient d√©j√† dans le trac√© (elles sont d√©j√† g√©r√©es)
            const newTerritory = filledTiles.filter(tile => !trail.some(t => t.x === tile.x && t.y === tile.y));

            // Ajouter les nouvelles tuiles au territoire
            territory.push(...newTerritory);
            
            // Mettre √† jour le score
            updateScore();
        }

        /**
         * Calcule et affiche le pourcentage de territoire captur√©.
         */
        function updateScore() {
            territoryArea = territory.length;
            const totalArea = gridCols * gridRows;
            const percent = (territoryArea / totalArea) * 100;
            document.getElementById('area-score').textContent = percent.toFixed(2);
        }

        // --- FONCTIONS DE DESSIN (RENDU) ---

        function draw() {
            // 1. Nettoyer l'√©cran
            ctx.clearRect(0, 0, WIDTH, HEIGHT);

            // 2. Dessiner le territoire
            ctx.fillStyle = BASE_COLOR;
            territory.forEach(t => {
                ctx.fillRect(t.x * TILE_SIZE, t.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });

            // 3. Dessiner la ligne (le trac√©)
            ctx.fillStyle = TRAIL_COLOR;
            trail.forEach(t => {
                ctx.fillRect(t.x * TILE_SIZE, t.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });

            // 4. Dessiner le joueur
            ctx.fillStyle = PLAYER_COLOR;
            ctx.beginPath();
            // Dessiner un cercle pour le joueur
            ctx.arc(
                player.x * TILE_SIZE + TILE_SIZE / 2, 
                player.y * TILE_SIZE + TILE_SIZE / 2, 
                TILE_SIZE / 2, 
                0, 
                Math.PI * 2
            );
            ctx.fill();
        }

        // --- BOUCLE DE JEU PRINCIPALE ---
        let lastUpdateTime = 0;
        const gameTick = 100; // Mouvement toutes les 100 millisecondes (10 cases/seconde)

        function gameLoop(timestamp) {
            if (isDead) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                ctx.fillStyle = 'white';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER !', WIDTH / 2, HEIGHT / 2);
                return; // Arr√™ter la boucle
            }
            
            // Mise √† jour de la logique √† intervalles fixes
            if (timestamp - lastUpdateTime > gameTick) {
                movePlayer();
                lastUpdateTime = timestamp;
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- INITIALISATION ---
        function init() {
            initializeTerritory();
            updateScore();
            requestAnimationFrame(gameLoop);
        }

        window.onload = init;
    </script>
</body>
</html>
