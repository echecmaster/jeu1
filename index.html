<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morpion Contre l'IA</title>
    <style>
        /* Styles CSS */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f4f4f9;
            color: #333;
        }

        h1 {
            color: #007bff;
            margin-bottom: 20px;
        }

        #controls {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #difficulty-select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #007bff;
            margin-right: 10px;
        }

        button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            background-color: #28a745;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #218838;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 5px;
            margin: 20px 0;
            background-color: #333;
            border: 5px solid #333;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .cell {
            width: 100px;
            height: 100px;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .cell:hover:not(:empty) {
            cursor: default; /* Emp√™che le curseur de pointer sur les cases d√©j√† jou√©es */
        }

        .cell:hover:empty {
            background-color: #e9e9e9;
        }

        .cell.x {
            color: #007bff; /* Bleu pour X */
        }

        .cell.o {
            color: #dc3545; /* Rouge pour O */
        }

        #message {
            margin-top: 15px;
            font-size: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <h1>üéÆ Morpion Contre l'IA</h1>

    <div id="controls">
        <label for="difficulty-select">Difficult√© :</label>
        <select id="difficulty-select">
            <option value="easy">Facile</option>
            <option value="normal">Normal</option>
            <option value="hard">Difficile</option>
            <option value="impossible">Impossible</option>
        </select>
        <button onclick="startGame()">Nouvelle Partie</button>
    </div>

    <div id="game-board">
        </div>

    <div id="message">Cliquez sur **Nouvelle Partie** pour commencer.</div>

    <script>
        // Variables globales
        let board;
        let cells;
        let currentPlayer = 'X'; // Le joueur humain commence toujours
        let gameActive = false;
        let difficulty = 'impossible'; // Difficult√© par d√©faut

        // Combinaisons gagnantes
        const WINNING_COMBOS = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Lignes
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Colonnes
            [0, 4, 8], [2, 4, 6]             // Diagonales
        ];

        // √âl√©ments du DOM
        const gameBoard = document.getElementById('game-board');
        const messageElement = document.getElementById('message');
        const difficultySelect = document.getElementById('difficulty-select');

        // Initialisation du jeu
        document.addEventListener('DOMContentLoaded', () => {
            difficultySelect.addEventListener('change', (e) => {
                difficulty = e.target.value;
            });
            createBoardCells();
        });

        // Fonction pour cr√©er les cellules du plateau
        function createBoardCells() {
            gameBoard.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                cell.addEventListener('click', handleCellClick);
                gameBoard.appendChild(cell);
            }
            cells = document.querySelectorAll('.cell');
        }

        // Fonction pour d√©marrer/r√©initialiser le jeu
        function startGame() {
            board = Array(9).fill(null);
            currentPlayer = 'X';
            gameActive = true;
            messageElement.textContent = "Votre tour (X)";
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('x', 'o');
                cell.addEventListener('click', handleCellClick, { once: true });
            });
            difficulty = difficultySelect.value;
            // Si l'IA (O) doit commencer, l'IA joue imm√©diatement
            // Note : Par convention, le joueur (X) commence dans cette impl√©mentation.
        }

        // Gestion du clic sur une cellule
        function handleCellClick(e) {
            const cell = e.target;
            const index = parseInt(cell.dataset.index);

            if (!gameActive || board[index] !== null || currentPlayer === 'O') {
                return;
            }

            // Mouvement du joueur (X)
            makeMove(cell, index, currentPlayer);

            if (checkGameStatus()) {
                return;
            }

            // Changement au tour de l'IA (O)
            currentPlayer = 'O';
            messageElement.textContent = "Tour de l'IA (O)...";

            // D√©lai pour simuler la "r√©flexion" de l'IA
            setTimeout(aiMove, 500);
        }

        // Fonction pour effectuer un mouvement
        function makeMove(cell, index, player) {
            board[index] = player;
            cell.textContent = player;
            cell.classList.add(player.toLowerCase());
            cell.removeEventListener('click', handleCellClick); // Emp√™che de recliquer
        }

        // V√©rifie l'√©tat du jeu (victoire ou √©galit√©)
        function checkGameStatus() {
            if (checkWin(board, currentPlayer)) {
                messageElement.textContent = `üéâ Le joueur ${currentPlayer} gagne !`;
                gameActive = false;
                return true;
            } else if (board.every(cell => cell !== null)) {
                messageElement.textContent = "ü§ù √âgalit√© !";
                gameActive = false;
                return true;
            }
            return false;
        }

        // V√©rifie si un joueur a gagn√©
        function checkWin(currentBoard, player) {
            return WINNING_COMBOS.some(combination => {
                return combination.every(index => {
                    return currentBoard[index] === player;
                });
            });
        }

        // Logique de jeu de l'IA (O)
        function aiMove() {
            if (!gameActive) return;

            let moveIndex;

            switch (difficulty) {
                case 'easy':
                    moveIndex = getEasyMove(board);
                    break;
                case 'normal':
                    moveIndex = getNormalMove(board);
                    break;
                case 'hard':
                    moveIndex = getHardMove(board);
                    break;
                case 'impossible':
                default:
                    moveIndex = getBestMove(board);
                    break;
            }

            if (moveIndex !== undefined && board[moveIndex] === null) {
                const cell = cells[moveIndex];
                makeMove(cell, moveIndex, 'O');

                if (!checkGameStatus()) {
                    // Changement au tour du joueur (X)
                    currentPlayer = 'X';
                    messageElement.textContent = "Votre tour (X)";
                }
            }
        }

        // --- Strat√©gies d'IA par Difficult√© ---

        // 1. IA Facile (Coup al√©atoire)
        function getEasyMove(currentBoard) {
            const availableMoves = currentBoard
                .map((val, index) => val === null ? index : null)
                .filter(index => index !== null);

            if (availableMoves.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableMoves.length);
                return availableMoves[randomIndex];
            }
            return undefined; // √âgalit√© ou erreur (ne devrait pas arriver si le jeu est actif)
        }

        // 2. IA Normale (Bloque le joueur 50% du temps, sinon al√©atoire)
        function getNormalMove(currentBoard) {
            if (Math.random() < 0.5) { // 50% de chance d'√™tre "stupide"
                return getEasyMove(currentBoard);
            }

            // Essayer de gagner
            let winningMove = findWinningMove(currentBoard, 'O');
            if (winningMove !== undefined) return winningMove;

            // Essayer de bloquer le joueur
            let blockingMove = findWinningMove(currentBoard, 'X');
            if (blockingMove !== undefined) return blockingMove;

            // Sinon, coup al√©atoire
            return getEasyMove(currentBoard);
        }

        // 3. IA Difficile (Minimax avec profondeur limit√©e)
        function getHardMove(currentBoard) {
            // Utilise Minimax mais avec une profondeur limit√©e (ex: 2 ou 3)
            // Pour simplifier, on utilisera une version qui ne va pas jusqu'au bout,
            // mais qui privil√©gie les coups centraux/coins et bloque le joueur.
            // On peut aussi utiliser Minimax complet avec une probabilit√© d'erreur (voir Impossible pour le Minimax complet)
            if (Math.random() < 0.2) { // 20% de chance d'erreur (Minimax avec un coup al√©atoire au lieu du meilleur)
                return getEasyMove(currentBoard);
            }
            // Sinon, coup "presque" parfait (Minimax complet ici, mais vous pourriez le simplifier)
            return getBestMove(currentBoard);
        }

        // Fonction utilitaire pour trouver un coup gagnant/bloquant
        function findWinningMove(currentBoard, player) {
            for (const combo of WINNING_COMBOS) {
                const [a, b, c] = combo;
                const line = [currentBoard[a], currentBoard[b], currentBoard[c]];
                const playerTiles = line.filter(tile => tile === player).length;
                const emptyTiles = line.filter(tile => tile === null).length;

                if (playerTiles === 2 && emptyTiles === 1) {
                    // C'est le coup !
                    return combo.find(index => currentBoard[index] === null);
                }
            }
            return undefined;
        }

        // 4. IA Impossible (Algorithme Minimax complet)
        function getBestMove(currentBoard) {
            return minimax(currentBoard, 'O').index;
        }

        // L'algorithme Minimax
        function minimax(newBoard, player) {
            const availableSpots = newBoard
                .map((val, index) => val === null ? index : null)
                .filter(index => index !== null);

            // Conditions terminales
            if (checkWin(newBoard, 'X')) {
                return { score: -10 }; // X (joueur) gagne : score n√©gatif pour l'IA
            } else if (checkWin(newBoard, 'O')) {
                return { score: 10 };  // O (IA) gagne : score positif pour l'IA
            } else if (availableSpots.length === 0) {
                return { score: 0 };   // √âgalit√©
            }

            // Collecter tous les r√©sultats des mouvements possibles
            const moves = [];

            for (let i = 0; i < availableSpots.length; i++) {
                const move = {};
                const index = availableSpots[i];

                move.index = index;
                newBoard[index] = player; // Faire le mouvement

                // Appeler minimax r√©cursivement
                if (player === 'O') {
                    const result = minimax(newBoard, 'X'); // Le prochain joueur est X (le MINIMIZER)
                    move.score = result.score;
                } else {
                    const result = minimax(newBoard, 'O'); // Le prochain joueur est O (le MAXIMIZER)
                    move.score = result.score;
                }

                newBoard[index] = null; // Annuler le mouvement (Backtracking)
                moves.push(move);
            }

            // D√©terminer le meilleur mouvement
            let bestMove;
            if (player === 'O') {
                // MAXIMIZER (IA) : choisir le mouvement avec le score le plus √©lev√©
                let bestScore = -Infinity;
                for (let i = 0; i < moves.length; i++) {
                    if (moves[i].score > bestScore) {
                        bestScore = moves[i].score;
                        bestMove = moves[i];
                    }
                }
            } else {
                // MINIMIZER (Joueur) : choisir le mouvement avec le score le plus faible
                let bestScore = Infinity;
                for (let i = 0; i < moves.length; i++) {
                    if (moves[i].score < bestScore) {
                        bestScore = moves[i].score;
                        bestMove = moves[i];
                    }
                }
            }

            return bestMove;
        }
    </script>
</body>
</html>
